import weaver.WeaverJps;

aspectdef MathAnalysis
	var mathFun = {};
	//Get functions from math.h
	//...
	//Hardcoded for now
	mathFun = {
		"sqrt": ["double"],
		"sqrtf": ["float"],
		"pow": ["double", "double"],
		"powf": ["float", "float"],
		"sin": ["double"],
		"sinf": ["float"],
		"cos": ["double"],
		"cosf": ["float"],
		"exp": ["double"],
		"expf": ["float"]	
	};

	call MathReport(mathFun);
	call MathCompare(mathFun);
	call MathReplace(mathFun);
end

aspectdef MathReport
	input
		mathFun
	end
	
	//Counter for occurences of each math.h function
	var occurrences = {};
	for (var f in mathFun) {
		occurrences[f] = 0;
	}
	
	//Count occurrences
	for (var elem of WeaverJps.search('call').chain()) {
		var fun = elem['call'].name;
		if (fun in occurrences)
			occurrences[fun] += 1;
	}

	//Report occurrences
	println("Occurrences of each math.f function (not showing functions with 0 occurrences):");
	for (var f in occurrences) {
		if (occurrences[f] > 0)
			println(f + ": " + occurrences[f]);
	}
	println("");
end

aspectdef MathCompare
	input
		mathFun
	end

	//Compare, for each call, the type of arguments and the function signature
	println("Type of arguments being passed to each call to a math.h function:");
	for (var elem of WeaverJps.search('call').chain()) {
		var fun = elem['call'].name;
		if (fun in mathFun) {
			var args = elem['call'].args;
			var types = [];
			for (var i = 0; i < args.length; i++)
				types.push(args[i].type.builtinKind);
			println("-----------\nSig: " + elem['call'].signature/*mathFun[fun]*/ + "\nArgs: " + types);
		}
	}
	println("");
end

aspectdef MathReplace
	input
		mathFun
	end

	var includedSqrt = false;

	for (var elem of WeaverJps.search('call').chain()) {
		var fun = elem['call'].name;
		if (fun in mathFun) {
			var args = elem['call'].args;
			var types = [];
			for (var i = 0; i < args.length; i++)
				types.push(args[i].type.builtinKind);

			//sqrtf -> rsqrt32
			if (fun == "sqrtf" || (fun == "sqrt" && !types.includes("Double", 0))) {
				println("Replacing sqrtf for rsqrt32");
				elem['call'].setName("rsqrt32");
				if (!includedSqrt)
					elem['call'].root.addExtraSource("rsqrt.h");
				
			}
			//sqrt -> rsqrt64
			if (fun == "sqrt" && types.includes("Double", 0)) {
				println("Replacing sqrt for sqrt64");
				elem['call'].setName("rsqrt64");
				if (!includedSqrt)
					elem['call'].root.addExtraInclude("rsqrt.h");
					includedSqrt = true;
			}
			//pow(d, Int) -> d * ... * d
			if ((fun == "pow" || fun == "powf") && types[1] == "Int") {
				println("Replacing " + fun + " for explicit multiplication");
			}
				
			var isFloat = fun.substr(fun.length - 1) == "f";
			if (!isFloat && !fun.includes("sqrt", 0)) {
				var newFun = fun + "f";
				elem['call'].setName(newFun);
				println("Replacing " + fun + " for " + newFun); 
			}
		}
	}
end