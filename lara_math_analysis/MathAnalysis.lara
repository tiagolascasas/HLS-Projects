import weaver.WeaverJps;
import clava.ClavaJoinPoints;
import clava.Clava;


aspectdef MathAnalysis
	var mathFun = {};
	//Get functions from math.h
	//...
	//Hardcoded for now
	mathFun = {
		"sqrt": ["double"],
		"sqrtf": ["float"],
		"pow": ["double", "double"],
		"powf": ["float", "float"],
		"sin": ["double"],
		"sinf": ["float"],
		"cos": ["double"],
		"cosf": ["float"],
		"exp": ["double"],
		"expf": ["float"]	
	};

	call MathReport(mathFun);
	call MathCompare(mathFun);
	call MathReplace(mathFun);
end

aspectdef MathReport
	input
		mathFun
	end
	
	//Counter for occurences of each math.h function
	var occurrences = {};
	for (var f in mathFun) {
		occurrences[f] = 0;
	}
	
	//Count occurrences
	for (var elem of WeaverJps.search('call').chain()) {
		var fun = elem['call'].name;
		if (fun in occurrences)
			occurrences[fun] += 1;
	}

	//Report occurrences
	println("Occurrences of each math.f function (not showing functions with 0 occurrences):");
	for (var f in occurrences) {
		if (occurrences[f] > 0)
			println(f + ": " + occurrences[f]);
	}
	println("");
end

aspectdef MathCompare
	input
		mathFun
	end

	//Compare, for each call, the type of arguments and the function signature
	println("Type of arguments being passed to each call to a math.h function:");
	for (var elem of WeaverJps.search('call').chain()) {
		var fun = elem['call'].name;
		if (fun in mathFun) {
			var args = elem['call'].args;
			var types = [];
			for (var i = 0; i < args.length; i++)
				types.push(args[i].type.builtinKind);
			println("-----------\nSig: " + elem['call'].signature/*mathFun[fun]*/ + "\nArgs: " + types);
		}
	}
	println("");
end

aspectdef MathReplace
	input
		mathFun
	end

	var includedSqrt = false;

	for (var elem of WeaverJps.search('call').chain()) {
		var fun = elem['call'].name;
		if (fun in mathFun) {
			var args = elem['call'].args;
			var types = [];
			for (var i = 0; i < args.length; i++)
				types.push(args[i].type.builtinKind);

			//sqrtf -> rsqrt32
			if (fun == "sqrtf" || (fun == "sqrt" && !types.includes("Double", 0))) {
				println("Replacing sqrtf for rsqrt32");
				elem['call'].setName("rsqrt32");
				elem['call'].ancestor('file').addInclude("rsqrt.h");		
			}
			//sqrt -> rsqrt64
			if (fun == "sqrt" && types.includes("Double", 0)) {
				println("Replacing sqrt for sqrt64");
				elem['call'].setName("rsqrt64");
				elem['call'].ancestor('file').addInclude("rsqrt.h");
			}
			//pow(d, Int) -> d * ... * d
			if ((fun == "pow" || fun == "powf") && types[1] == "Int" && /[0-9]\d*/.test(args[1].code)) {
				println("Replacing " + fun + " for explicit multiplication");
				var n = parseInt(args[1].code);
				var expr = ClavaJoinPoints.parenthesis(args[0]);

				if (n >= 2) {
					node = ClavaJoinPoints.binaryOp("mul", expr.copy(), expr.copy(), types[0]);
					for (var i = 3; i <= n; i++) {
						node = ClavaJoinPoints.binaryOp("mul", expr.copy(), node, types[0]);
					}
					elem['call'].replaceWith(node);
				}
				if (n == 1) {
					elem['call'].replaceWith(expr);
				}
				if (n == 0) {
					elem['call'].replaceWith(ClavaJoinPoints.integerLiteral(1));
				}
			}
			//conversion from using functions with doubles to floats	
			var isFloat = fun.substr(fun.length - 1) == "f";
			if (!isFloat && !fun.includes("sqrt", 0)) {
				var newFun = fun + "f";
				if (newFun in mathFun) {
					elem['call'].setName(newFun);
					println("Replacing " + fun + " for " + newFun);
				}
			}
		}
	}
end