import weaver.WeaverJps;
import clava.ClavaJoinPoints;
import clava.Clava;
import lara.code.Logger;
import PrintAST;

/**
	Source code assumptions:
	- Arrays have predetermined size
	- No pointers
	- Variables declared/initialized one at a time (e.g. no "int x, y = 0")
**/
aspectdef DataflowGraph
	input
		funName
	end

	//Get function root
	var root;
	var filename = Clava.getProgram().files[0].name;
	var basename = filename.split(".");
	var filename = basename[0] + ".dot";
	var logger = new Logger(undefined, filename);
	//replace by filter, not sure of the syntax
	for (var elem of WeaverJps.search("function").chain()){
		if (elem["function"].name == funName)
			root = elem["function"];
	}	
	call PrintAST(root);

	//Get scope and params
	var scope;
	var params = [];
	for (var i = 0; i < root.children.length; i++) {
		if (root.children[i].joinPointType == "scope")
			scope = root.children[i];
		if (root.children[i].joinPointType == "param")
			params.push(root.children[i]);
	}

	//Get local variables
	var vars = getVars(scope);
	vars = vars.filter(isNotLoopVar);

	//Begin graph: declare variables for counting
	var firstOp = scope.children[0];
	logger.text("Digraph G {\\n").log(firstOp, true);
	firstOp.insertBefore(ClavaJoinPoints.stmtLiteral("//Begin: counter variables"));
	for (var i = 0; i < params.length; i++)
		firstOp.insertBefore(declareVariable(params[i]));
	for (var i = 0; i < vars.length; i++)
		firstOp.insertBefore(declareVariable(vars[i]));
	firstOp.insertBefore(ClavaJoinPoints.stmtLiteral("int n_const = 0;"));
	firstOp.insertBefore(ClavaJoinPoints.stmtLiteral("int n_op = 0;"));
	firstOp.insertBefore(ClavaJoinPoints.stmtLiteral("int n_out = 0;"));
	firstOp.insertBefore(ClavaJoinPoints.stmtLiteral("int ne = 0;"));
	firstOp.insertBefore(ClavaJoinPoints.stmtLiteral("//End: counter variables"));

	//Get index of first operation
	var startIdx = -1;
	for (var i = 0; i < scope.children.length; i++) {
		if (scope.children[i].astId == firstOp.astId)
			startIdx = i;
	}
	
	//Traverse the AST
	var nodes = [];
	for (var i = startIdx; i < scope.children.length; i++) {
		nodes.push(scope.children[i]);
	}
	for (var i = 0; i < nodes.length; i++) {
		explore(nodes[i], logger);
	}

	//End graph
	var ret = scope.children[scope.children.length-2];
	logger.text("}\\n").log(ret, true);
end

function getVars(root) {
	var vars = [];
	for (var i = 0; i < root.children.length; i++) {
		if (root.children[i].joinPointType == "vardecl")
			vars.push(root.children[i]);
		else
			vars = vars.concat(getVars(root.children[i]));
	}
	return vars;
}

function isNotLoopVar(varName) {
	//A smarter way would be to actually look through the loops
	//But let's assume we just want to filter out typical counter names for now
	var names = ["i", "j", "k"];
	return !names.includes(varName.name);
}

function declareVariable(decl) {
	var tokens = decl.code.split(" ");
	for (var i = 0; i < tokens.length; i++) {
		if (tokens[i].indexOf(decl.name) != -1)
			tokens[i] = "n_" + tokens[i];
	}
	tokens = tokens.join(" ");
	if (tokens.indexOf("=") == -1) {
		if (tokens.indexOf("[") != -1)
			tokens += " = {0};";
		else
			tokens += " = 0;";
	}
	if (tokens[tokens.length - 1] != ";")
		tokens += ";";
	return ClavaJoinPoints.stmtLiteral(tokens);
}

function incrementVar(node, variable) {
	node.insertBefore(ClavaJoinPoints.stmtLiteral(variable + "++;"));
}

function explore(node, logger) {
	//println(node.joinpointType);
	if (node.joinPointType == "expression") {
		handleExpression(node, logger);
	}
	if (node.joinPointType == "vardecl") {
		handleVarDecl(node, logger);
	}
	for (var i = 0; i < node.children.length; i++)
		explore(node.children[i], logger);
}

function handleExpression(node, logger) {
	//expression is a constant
	incrementVar(node, "n_const");
	logger.text("const")
		.int(ClavaJoinPoints.varRef("n_const", ClavaJoinPoints.builtinType("int")))
		.text(" [label=\\\"" + node.code + "\\\", att1=const];\\n")
		.log(node, true); 
	//TODO: other cases
}

function handleVarDecl(node, logger) {
	if (!isNotLoopVar(node))
		return;
	logger.text(node.name)
		.text(" [label=\\\"" + node.name + "\\\", att1=var];\\n")
		.log(node, true);
}