import weaver.WeaverJps;
import clava.ClavaJoinPoints;
import clava.Clava;
import lara.code.Logger;
import PrintAST;

/**
	Source code assumptions:
	- Arrays have predetermined size
	- No pointers
	- Variables declared/initialized one at a time (e.g. no "int x, y = 0")
**/
aspectdef DataflowGraph
	input
		funName
	end

	//Get function root
	var root;
	var filename = Clava.getProgram().files[0].name;
	var basename = filename.split(".");
	var filename = basename[0] + ".dot";
	var logger = new Logger(undefined, filename);
	//replace by filter, not sure of the syntax
	for (var elem of WeaverJps.search("function").chain()){
		if (elem["function"].name == funName)
			root = elem["function"];
	}	
	call PrintAST(root);

	//Get scope and params
	var scope;
	var params = [];
	for (var i = 0; i < root.children.length; i++) {
		if (root.children[i].joinPointType == "scope")
			scope = root.children[i];
		if (root.children[i].joinPointType == "param")
			params.push(root.children[i]);
	}

	//Get local variables
	var vars = getVars(scope);
	vars = vars.filter(isNotLoopVar);

	//Begin graph: declare variables for counting
	var firstOp = scope.children[0];
	logger.text("Digraph G {\\n").log(firstOp, true);
	firstOp.insertBefore(ClavaJoinPoints.stmtLiteral("//Begin: counter variables"));
	for (var i = 0; i < params.length; i++)
		firstOp.insertBefore(declareVariable(params[i]));
	for (var i = 0; i < vars.length; i++)
		firstOp.insertBefore(declareVariable(vars[i]));
	firstOp.insertBefore(ClavaJoinPoints.stmtLiteral("int n_const = 0;"));	//Counts constants
	firstOp.insertBefore(ClavaJoinPoints.stmtLiteral("int n_op = 0;"));		//Counts operations (e.g. +, -)
	firstOp.insertBefore(ClavaJoinPoints.stmtLiteral("int n_out = 0;"));		
	firstOp.insertBefore(ClavaJoinPoints.stmtLiteral("int n_edge = 0;"));		//Counts edges
	firstOp.insertBefore(ClavaJoinPoints.stmtLiteral("int n_temp = 0;"));		//Counts temporary vars
	firstOp.insertBefore(ClavaJoinPoints.stmtLiteral("//End: counter variables"));
	//Get index of first operation
	var startIdx = -1;
	for (var i = 0; i < scope.children.length; i++) {
		if (scope.children[i].astId == firstOp.astId)
			startIdx = i;
	}
	//Get scope-level nodes
	var nodes = [];
	for (var i = startIdx; i < scope.children.length; i++) {
		nodes.push(scope.children[i]);
	}
	//Insert prints for variable declarations
	for (var i = 0; i < nodes.length; i++) {
		createNodes(nodes[i], logger);
	}
	//Connect nodes and create operations
	for (var i = 0; i < nodes.length; i++) {
		connectNodes(nodes[i], logger);
	}
	//End graph
	var ret = scope.children[scope.children.length-2];
	logger.text("}\\n").log(ret, true);
end

function getVars(root) {
	var vars = [];
	for (var i = 0; i < root.children.length; i++) {
		if (root.children[i].joinPointType == "vardecl")
			vars.push(root.children[i]);
		else
			vars = vars.concat(getVars(root.children[i]));
	}
	return vars;
}

function isNotLoopVar(node) {
	//A smarter way would be to actually look through the loops
	//But let's assume we just want to filter out typical counter names for now
	var names = ["i", "j", "k"];
	return !names.includes(node.name);
}

function declareVariable(decl) {
	var tokens = decl.code.split(" ");
	for (var i = 0; i < tokens.length; i++) {
		if (tokens[i].indexOf(decl.name) != -1)
			tokens[i] = "n_" + tokens[i];
	}
	tokens = tokens.join(" ");
	if (tokens.indexOf("=") == -1) {
		if (tokens.indexOf("[") != -1)
			tokens += " = {0};";
		else
			tokens += " = 0;";
	}
	if (tokens[tokens.length - 1] != ";")
		tokens += ";";
	return ClavaJoinPoints.stmtLiteral(tokens);
}

function incrementVar(node, variable) {
	node.insertBefore(ClavaJoinPoints.stmtLiteral(variable + "++;"));
}

//Create nodes
function createNodes(node, logger) {
	var nodes = [];
	if (node.numChildren > 0)
		nodes = node.children.slice();
	if (node.joinPointType == "expression") {
		addConstant(node, logger);
	}
	if (node.joinPointType == "vardecl") {
		addVar(node, logger);
	}
	if (node.joinPointType == "binaryOp" || node.joinPointType == "unaryOp") {
		if (node.parent.parent.type != "loop")
			addOperation(node, logger);
	}
	if (node.joinPointType == "arrayAccess") {
		addArrayAccess(node, logger);
	}
	if (node.joinPointType == "varref") {
		addVarref(node, logger);
	}
	for (var i = 0; i < nodes.length; i++)
		createNodes(nodes[i], logger);
}

//Create edges (connect the nodes)
function connectNodes(node, logger) {
	var nodes = [];
	if (node.numChildren > 0)
		nodes = node.children.slice();
	if (node.joinPointType == "statement") {
		if (node.parent.joinPointType != "loop") {
			connectStatement(node, logger);
			return;
		}
	}
	for (var i = 0; i < nodes.length; i++)
		connectNodes(nodes[i], logger);
}

//Functions to add nodes
function addConstant(node, logger) {
	//expression is a constant
	incrementVar(node, "n_const");
	logger.text("const")
		.int(ClavaJoinPoints.varRef("n_const", ClavaJoinPoints.builtinType("int")))
		.text(" [label=\\\"" + node.code + "\\\", att1=const];\\n")
		.log(node, true);
	node.setUserField("label", {"name": "const", "var": "n_const"}); 
	//TODO: other cases, if justified
}

function addVar(node, logger) {
	if (!isNotLoopVar(node))
		return;
	logger.text(node.name)
		.text(" [label=\\\"" + node.name + "\\\", att1=var];\\n")
		.log(node, true);
	node.setUserField("label", {"name": node.name, "var": "none"}); 
}

function addOperation(node, logger) {
	incrementVar(node, "n_op");
	logger.text("\\\"op")
		.int(ClavaJoinPoints.varRef("n_op", ClavaJoinPoints.builtinType("int")))
		.text("\\\" [label=\\\"" + node.kind + ", att1=op\\\"]\\n")
		.log(node, true);
	node.setUserField("label", {"name": "op%d", "var": "n_op"});
	//Also generate node for temporary result if it is part of a larger operation
	if (node.parent.type == "unaryOp" || node.parent.type == "binaryOp") {
		incrementVar(node, "n_op");
		logger.text("\\\"temp")
			.int(ClavaJoinPoints.varRef("n_temp", ClavaJoinPoints.builtinType("int")))
			.text("\\\" [label=\\\"temp_i" + node.line + "_")
			.int(ClavaJoinPoints.varRef("n_temp", ClavaJoinPoints.builtinType("int")))
			.text("\\\"]\\n")
			.log(node, true);
		node.setUserField("temp", {"name": "temp_i" + node.line + "_", "var": "n_temp"});
	}
}

function addArrayAccess(node, logger) {
	logger.text("\\\"" + node.children[0].code + "[")
		.int(ClavaJoinPoints.varRef(node.children[1].code, ClavaJoinPoints.builtinType("int")))
		.text("]\\\" [label=\\\"" + node.children[0].code + "[")
		.int(ClavaJoinPoints.varRef(node.children[1].code, ClavaJoinPoints.builtinType("int")))
		.text("]\\\"]\\n")
		.log(node, true);
	node.setUserField("label", {"name": node.children[0].code + "[]", "var": node.children[1].code});
}

function addVarref(node, logger) {
	//TODO, not relevant for current example
	//Same as array access, but do not perform if parent is array access
	if (isNotLoopVar(node)) {
		if (node.parent.joinPointType != "binaryOp" && node.parent.joinPointType != "unaryOp")
			return;
		incrementVar(node, "n_" + node.name);
		logger.text("\\\"" + node.name)
			.int(ClavaJoinPoints.varRef("n_" + node.name, ClavaJoinPoints.builtinType("int")))
			.text("\\\" [label=\\\"" + node.name + "\\\"]\\n")
			.log(node, true);
		node.setUserField("label", {"name": node.name, "var": "n_" + node.name});
	}
}

//Functions to add edges
function addEdge(node, logger, source, dest) {
	incrementVar(node, "n_edge");
	logger.text(source.name);
	if (source.var != "none")
		logger.int(ClavaJoinPoints.varRef(source.var, ClavaJoinPoints.builtinType("int")));
	logger.text(" -> " + dest.name);
	if (dest.var != "none")
		logger.int(ClavaJoinPoints.varRef(dest.var, ClavaJoinPoints.builtinType("int")));
	logger.text(" [label=\\\"")
		.int(ClavaJoinPoints.varRef("n_edge", ClavaJoinPoints.builtinType("int")))
		.text("\\\", ord=\\\"")
		.int(ClavaJoinPoints.varRef("n_edge", ClavaJoinPoints.builtinType("int")))
		.text("\\\"]\\n")
		.log(node, true);
}

function connectStatement(node, logger) {
	if (node.numChildren == 0)
		return;
	var child = node.firstChild;
	if (child.numChildren == 0) 
		return;

	println("Handling expression \"" + node.code + "\"");
	if (child.joinPointType == "vardecl") {
		if (child.firstChild.joinPointType == "expression") {
			var source = child.firstChild.userField("label");
			var dest = child.userField("label");
			addEdge(node, logger, source, dest);
		}			
	}
	if (child.joinPointType == "binaryOp") {
		
	}
	if (child.joinPointType == "unaryOp") {
		
	}
}