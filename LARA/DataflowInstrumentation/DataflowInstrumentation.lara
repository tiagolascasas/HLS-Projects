import weaver.WeaverJps;
import clava.ClavaJoinPoints;
import clava.Clava;
import lara.code.Logger;
import PrintAST;

/**
	Source code assumptions:
	- Arrays have predetermined size
	- No pointers
	- Variables declared/initialized one at a time (e.g. no "int x, y = 0")
**/

var interfaces = {};
var locals = {};
var logger = null;
var CM = "\\\"";
var NL = "\\n";

aspectdef DataflowInstrumentation
	input
		funName
	end
	
	//Get function root
	var root;
	var filename = Clava.getProgram().files[0].name;
	var basename = filename.split(".");
	var filename = funName + ".dot";
	logger = new Logger(undefined, filename);
	//replace by filter, not sure of the syntax
	for (var elem of WeaverJps.search("function").chain()){
		if (elem["function"].name == funName)
			root = elem["function"];
	}	
	call PrintAST(root);

	//Get scope and interface
	var scope;
	for (var i = 0; i < root.children.length; i++) {
		if (root.children[i].joinPointType == "scope")
			scope = root.children[i];
		if (root.children[i].joinPointType == "param")
			registerInterface(root.children[i]);
	}
	var children = scope.children.slice();

	//Get global vars as interfaces
	for (var elem of WeaverJps.search("vardecl")) {
		if (elem.isGlobal)
			registerInterface(elem);
	}

	//Get local vars
	for (var elem of WeaverJps.search("function", {name: funName}).search("vardecl")){
		registerLocal(elem);
	}

	//Begin graph and create counters
	var firstOp = scope.children[0];
	logger.text("Digraph G {\\n").log(firstOp, true);
	
	createSeparator(firstOp);
	createDefaultCounters(firstOp);
	for (var entry in locals) {
		declareLocalCounter(firstOp, entry);
	}
	for (var entry in interfaces) {
		declareInterfaceCounter(firstOp, entry);
	}
	
	//Load all interfaces
	loadInterfaces(scope);
	createSeparator(firstOp);

	//Go through each statement and generate nodes and edges
	explore(children);

	//Close graph
	logger.text("}").log(scope.children[scope.length - 1]);
	
end

function explore(children) {
	for (var i = 0; i < children.length; i++) {
		var child = children[i];
		if (child.joinPointType == "statement")
			handleStatement(child.children[0]);
		if (child.joinPointType == "loop") {
			explore(child.children[3].children.slice());
		}
	}
}

//--------------------
// Counters
//--------------------
function createDefaultCounters(node) {
	var defCounters = ["const", "temp", "op", "mux"];
	for (var i = 0; i < defCounters.length; i++)
		node.insertBefore(ClavaJoinPoints.stmtLiteral("int n_" + defCounters[i] + " = 0;"));
	node.insertBefore(ClavaJoinPoints.stmtLiteral("int ne = 0;"));
}

function declareInterfaceCounter(node, name) {
	var info = interfaces[name];
	var init = (info.length == 1) ? " = 0;" : " = {0};";
	node.insertBefore(ClavaJoinPoints.stmtLiteral("int " + getCounterOfVar(name, info) + init));
}

function declareLocalCounter(node, name) {
	var info = locals[name];
	var init = (info.length == 1) ? " = 0;" : " = {0};";
	node.insertBefore(ClavaJoinPoints.stmtLiteral("int " + getCounterOfVar(name, info) + init));
}

function splitMulti(str, tokens) {
	var tempChar = tokens[0];
	for(var i = 1; i < tokens.length; i++){
		str = str.split(tokens[i]).join(tempChar);
	}
	str = str.split(tempChar);
	var newStr = [];
	for (var i = 0; i < str.length; i++) {
		if (str[i] != "")
			newStr.push(str[i]);
	}
	return newStr;
}

function registerInterface(param) {
	var tokens = splitMulti(param.code, [' ', "]", "["]);
	var interName = tokens[1];
	tokens.splice(1, 1);
	interfaces[interName] = tokens;
}

function registerLocal(local) {
	var tokens = splitMulti(local.code, [' ', "]", "["]);
	var locName = tokens[1];
	if (locals[locName] != undefined)
		return;
	if (interfaces[locName] != undefined)
		return;
	tokens.splice(1, 1);
	if (tokens.indexOf("=") != -1)
		tokens = tokens.slice(0, tokens.indexOf("="));
	locals[locName] = tokens;
}

function getCounterOfVar(name, info) {
	var str = "n_" + name;
	for (var i = 1; i < info.length; i++)
		str += "[" + info[i] + "]";
	return str;
}

function loadInterfaces(node) {

}

function isLocal(varName) {
	return (locals[varName] != undefined);
}

function isInterface(varName) {
	return (interfaces[varName] != undefined);
}

//--------------------
// Create nodes
//--------------------
function refCounter(name) {
	name = "n_" + name;
	return ClavaJoinPoints.varRef(name, ClavaJoinPoints.builtinType("int"));
}

function refArrayCounter(name, indexes) {
	name = "n_" + name;
	for (var i = 0; i < indexes.length; i++)
		name += "[" + indexes[i] + "]";
	return ClavaJoinPoints.stmtLiteral(name);
}

function refAnyExpr(code) {
	return ClavaJoinPoints.stmtLiteral(code);
}

function incrementCounter(node, variable, indexes) {
	if (variable == "ne") {
		node.insertBefore(ClavaJoinPoints.stmtLiteral("ne++;"));
		return;
	}
	if (indexes != undefined) {
		var access = "";
		for (var i = 0; i < indexes.length; i++) {
			access += "[" + indexes[i] + "]";
		}
		node.insertBefore(ClavaJoinPoints.stmtLiteral("n_" + variable + accesses + "++;"));
	}
	else {
		node.insertBefore(ClavaJoinPoints.stmtLiteral("n_" + variable + "++;"));
	}	
}

function storeVar(node, variable) {
	incrementCounter(node, variable);
	var att1 = "var";
	var att2 = "";
	var att3 = "";
	if (isLocal(variable)) {
		att2 = "loc";
		att3 = locals[variable][0];
	}
	if (isInterface(variable)) {
		att2 = "inte";
		att3 = interfaces[variable][0];
	}
	logger.text(CM + variable + "_")
		.int(refCounter(variable))
		.text(CM + " [label=" + CM + variable + CM + ", att1=" + att1 + ", att2=" + att2 + ", att3=" + att3 + "];" + NL)
		.log(node, true);
}

function storeArray(node, variable, indexes) {
	incrementCounter(node, variable, indexes);
	var att1 = "var";
	var att2 = "";
	var att3 = "";
	if (isLocal(variable)) {
		att2 = "loc";
		att3 = locals[variable][0];
	}
	if (isInterface(variable)) {
		att2 = "inte";
		att3 = interfaces[variable][0];
	}
	logger.text(CM + variable );
	for (var i = 0; i < indexes.length; i++) {
		logger.text("[").int(refAnyExpr(indexes[i])).text("]");
	}
	logger.text("_").int(refArrayCounter(variable)).text("_l") + CM;
	logger.text(" [label=" + CM + variable);
	for (var i = 0; i < indexes.length; i++) {
		logger.text("[").int(refAnyExpr(indexes[i])).text("]");
	}
	logger.text(CM + ", att1=" + att1 + ", att2=" + att2 + ", att3=" + att3 + "];" + NL)
	.log(node, true);
}

function createOp(node, op) {
	incrementCounter(node, "op");
	logger.text(CM + "op")
		.int(refCounter("op"))
		.text(CM + " [label=" + CM + op + CM + ", att1=op];" + NL)
		.log(node, true);
}

function createMux(node) {
	//TODO: include OP attribute?
	incrementCounter(node, "mux");
	logger.text(CM + "mux")
		.int(refCounter("mux"))
		.text(CM + " [label=" + CM + "mux")
		.int(refCounter("mux"))
		.text(CM + ", att1=mux];" + NL)
		.log(node, true);
}

function createConst(node, num) {
	incrementCounter(node, "const");
	logger.text(CM + "const")
		.int(refCounter("const"))
		.text(CM + " [label=" + CM + num + CM + ", att1=const];" + NL)
		.log(node, true);
}

function createTemp(node, type) {
	incrementCounter(node, "temp");
	logger.text(CM + "temp")
		.int(refCounter("temp"))
		.text(CM + " [label=" + CM + "temp_l" + node.line + "_i" + CM + ", att1=var, att2=loc, att3=" + type + "];" + NL)
		.log(node, true);
}

function createSeparator(node) {
	var separator = "//---------------------";
	node.insertBefore(ClavaJoinPoints.stmtLiteral(separator));
}

//--------------------
// Create edges
//--------------------
function createEdge(node, source, dest) {
	incrementCounter("ne");
}

//--------------------
// Handle statements
//--------------------
function handleStatement(node) {
	var type = node.joinPointType;
	createSeparator(node);
	if (type == "vardecl")
		handleVardecl(node);
	if (type == "binaryOp")
		handleBinaryOp(node);
	if (type == "unaryOp")
		handleUnaryOp(node);
	createSeparator(node);
}

function handleVardecl(node) {
	println("vardecl found");
}

function handleBinaryOp(node) {
	println(node.kind);
	var opKind = mapOperation(node.kind);
	
	createOp(node, opKind);
	
}

function handleUnaryOp(node) {
	println(node.code);
}

//--------------------
// Utils
//--------------------
function mapOperation(op) {
	if (op.includes("add"))
		return "+";
	return "undefined_op";
}